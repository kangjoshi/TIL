## HTTP (HyperText Transfer Protocol)

HyperText 메시지를 교환하려고 고안 되었으나 지금은 Image, 음성파일에서 부터 JSON 까지 거의 모든 형태의 데이터 전송

##### 기반 프로토콜

TCP : HTTP/1.1, HTTP/2

UDP : HTTP/3

### HTTP 특징

##### 클라이언트 서버 구조

Request - Response 구조, 클라이언트는 서버에 요청을 보내고 서버로 부터 응답을 받는다.

##### 상태를 가지지 않는다. (Stateless)

서버가 클라이트의 상태를 보존하지 않는다. 

클라이언트는 서버에 요청시 필요한 정보를 넘겨서 원하는 상태로 동작하도록 한다.

##### 비 연결성

HTTP는 기본이 연결을 유지하지 않는다. 

동시 접속자가 많아도 실제 동시에 처리하는 요청은 많지 않다. 연결을 유지하지 않음으로 서버의 자원을 효율적으로 사용할 수 있다.

HTTP의 비 연결성은 매 연결마다 3-WAY-Handshake를 해야하기 때문에 요청이 많다면 연결 시간이 추가되는 단점이 있다.

이는 HTTP 지속 연결로 문제 해결할 수 있다. (HTTP/2, HTTP/3은 이 부분이 더 최적화 되었다.)



### HTTP 메시지

요청 메시지, 응답 메시지로 구분

Start-line : 시작 라인 - header : 헤더 - empty line : 공백라인 - message body : 본문 구조를 가지고 있다.



### HTTP 메서드

##### GET

리소스 조회

서버에 전달할 데이터는 query를 통해서 전달, 메시지 바디를 사용하여 전달할 수 있지만, 지원하지 않는 서버가 있으므로 권장하지 않음.

##### POST

요청 데이터 처리

메시지 바디를 통해 서버로 요청 데이터 전달

##### PUT

리소스가 있다면 대체, 없다면 생성한다.

리소스 전체를 변경한다.

##### PATCH

리소스 부분을 변경한다.

지원을 하지 않는 서버도 있을 수 있다.

##### DELETE

리소스를 제거한다.



#### HTTP 메서드의 속성

##### 안전 (GET)

호출해도 리소스를 변경하지 않는다.

##### 멱등 (GET, PUT, DELETE)

항상 동일한 결과를 반환한다. (외부 요인에 따른 리소스 변경까지는 고려 되지 않음.)

클라이언트가 같은 요청을 중복 해서 해도 되는지 판단하는 근거가 된다.

##### 캐시가능 (GET, POST, PATCH)

응답 결과를 캐시해서 사용해도 되는지

실무에서는 GET만 캐시로 사용, POST, PATCH는 메시지 바디 내용까지 캐시 키로 고려해야 하는데 구현이 쉽지 않다.



### HTTP 상태 코드

##### 1xx : 요청이 수신되어 처리 중

##### 2xx : 정상 처리

- 200 OK : 요청 성공
- 201 Created : 요청이 성공해서 새로운 리소스가 생성 됨. (생성된 리소스는 응답의 Location 헤더 필드로 넣어서 식별)
- 202 Accepted : 요청이 접수되었으나 처리는 완료되지 않았음. (배치 처리와 같은 곳에서 사용)
- 204 No Content : 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터는 없음.

##### 3xx : 요청을 완료하려면 유저 에이전트의 추가 행동이 필요

- 웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면 Location 위치로 자동 리다이렉트
- 301 Moved Permanently : 리소스의 URI가 영구적으로 이동, 검색 엔진에서도 변경 인지, 리다이렉트시 요청 메서드가 GET으로 변하고 본문은 사라질 수 있음.
- 308 Permanent Redirect : 리소스의 URI가 영구적으로 이동, 검색 엔진에서도 변경 인지, 리다이렉트시 요청 메서드의 메서드와 본문 유지
- 302 Found : 리소스의 URI이 일시적으로 변경, 리다이렉트시 요청 메서드가 GET으로 변하고 본문이 제거될 수 있음.
- 303 See Other : 리소스의 URI이 일시적으로 변경, 리다이렉트시 요청 메서드가 무조건 GET으로 변함 (302은 브라우저에 따라서 GET으로 변하지 않을 수 있음.)
- 307 Temporary Redirect : 리소스의 URI이 일시적으로 변경,  리다이렉트시 요청 메서드의 메서드와 분문 유지
- 304 Not Modified : 캐시를 목적으로 사용, 클라이언트에게 리소스가 수정되지 않았으므로 로컬 캐시를 재사용하라고 알려준다.

PRG : Post / Redirect / Get

POST로 주문후에 웹 브라우저를 새로고침하면? 중복 주문이 발생할 수 있음.

이를 방지하기 위해 POST 주문 후(200 또는 201이 아닌 302 + Location /order-result/1과 같이 응답을 내려 줌)에 주문 결과 화면으로 GET 메서드로 리다이렉트

##### 4xx : 클라이언트 오류

- 4xx 오류는 클라이언트가 이미 잘못된 요청을 하므로 똑같은 요청을 해도 실패할 것
- 400 Bad Request : 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음. (요청 파라미터가 잘못되었거나 API 스펙이 맞지 않음.)
- 401 Unauthorized : 인증 되지 않음. WWW-Authenticate 헤더와 함께 인증 방법 설명을 보내야한다.
- 403 Forbidden : 서버가 요청을 이해했지만 승인을 거부함. 인증은 되었지만 인가가 되지 않은 경우
- 404 Not Found : 요청 리소스를 찾을 수 없음.

##### 5xx : 서버 오류

- 5xx 오류는 서버 오류이므로 클라이언트는 똑같은 요청을 하면 성공할 수도 있음
- 500 Internal Server Error : 서버 문제로 오류 발생
- 503 Service Unavailable : 일시적인 서비스 이용 불가, Retry-After 헤더로 얼마뒤에 복구 되는지 보낼수 있음



### HTTP 헤더

HTTP 전송에 필요한 모든 부가 정보

표준 헤더와 필요시 임의로 지정하는 커스텀 헤더가 있다.

##### Header 종류

General 헤더 : 메시지 전체에 적용되는 정보

Request 헤더 : 요청 정보

- Referer : 이전 웹 페이지 주소 (유입 경로 분석 가능)
- User-Agent : 클라이언트 애플리케이션 정보
- Host : (필수) 요청한 호스트 정보, 하나의 서버가 여러 도메인을 처리해야 할 때 사용되는 정보
- Authorization : 클라이언트 인증 정보를 서버에 전달

Response 헤더 : 응답 정보

- Server : 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보
- Date : 메시지가 발생한 날짜와 시간
- Location : 3xx 응답시 Location 헤더가 있다면 Location 위치로 자동 이동한다. (201에서 온다면 생성된 후 주소)
- Allow : 405 응답시 허용 가능한 HTTP 메서드를 알려준다.
- Retry-After : 503 응답시 서비스가 언제까지 불능 상태인지 알려준다.
- WWW-Authenticate : 401 응답시 리소스 접근시 필요한 인증 정보를 알려준다.

Representation 헤더 : Payload(메시지 본문)을 해석할 수 있는 정보 제공

- 표현

  - 요청, 응답 둘다 사용된다.
  - Content-Type : 표현 데이터의 형식
  - Content-Encoding : 표현 데이터의 압축 방식 (gzip, deflate, identity 등)
  - Content-Language : 표현 데이터의 자연 언어 (ko, en, ko-KR, en-US 등)
  - Content-Length : 표현 데이터의 길이

- 협상

  - 요청시에만 사용

  - Quality Value 

    - 협상 우선순위 0~1 클수록 높은 우선순위 (Accept-Language : ko-KR;q=0.9,en-US;q=0.8)
    - 구체적인 것이 우선 (Accept: text/*, text/plain이면 text/plain -> text/\* 순으로)

  - Accept : 클라이언트가 선호하는 미디어 타입 전달

  - Accept-Charset : 클라이언트가 선호하는 문자 인코딩

  - Accept-Encoding : 클라이언트가 선호하는 압축 인코딩

  - Accept-Language : 클라이언트가 선호하는 자연 언어 (ko, en, ko-KR, en-US 등)(요청시 헤더가 추가하면 다중 언어 지원 서버는 이를 확인하여 알맞은 언어 메시지와 Content-Language 헤더를 전송)

    

### HTTP 전송방식

1. 단순 전송

   - 플레인 메시지를 보내고 받는다.

2. 압축 전송

   - 메시지를 압축하여 보내고 받는다.
   - Content-Encoding : {type}을 헤더에 붙여야한다. (무엇으로 압축하였는지)

3. 분할 전송

   - Transfer-Encoding : chunked을 헤더에 추가한다.
   - 크기를 알수 없기 때문에 Content-Length 헤더가 포함될 수 없다.
   - 전송 마지막에는 \\r\\n을 표기한다.

4. 범위 전송

   - 범위를 지정하여 받는다.
   - Content-Range : bytes 1001-2000 / 2000

   

### 쿠키

HTTP 요청시 쿠키는 자동으로 포함되어 전송된다. (네트워크 트래픽이 추가 유발되므로 가능한 최소한의 정보만 사용한다.)

보안에 민감한 데이터를 저장하면 안된다.

Set-Cookie : 서버가 클라이언트에게 넘겨주는 쿠키 정보, 전달받은 클라이언트는 이를 로컬 쿠키 저장소에 저장한다.

Expires, max-age : 쿠키의 생명 주기를 지정한다.

- 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시 쿠키는 삭제된다.
- 영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지되다 삭제된다.

Domain : 쿠키를 사용할 도메인을 지정한다. 생략한다면 현재 문서 기준 도메인만 적용된다. (하위에서는 접근 불가)

Path : 쿠키를 사용할 경로를 지정한다. 일반적으로 /로 지정한다.

Secure : https인 경우에만 전송하려면 지정한다.

HttpOnly : 쿠키를 HTTP 전송에만 사용하도록 한다.

SameSite : 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키를 전송한다.



### 캐시

응답시 헤더에 Cache-Control : max-age={시간}가 포함되어 있으면 클라이언트는 응답 결과를 캐시에 저장한다. 유효한 캐시라면 네트워크를 사용하지 않고 캐시되어 있는 데이터를 바로 사용한다.

##### 캐시 시간 초과

캐시 유효시간이 초과하여 서버에 다시 요청하면 두가지 케이스가 발생할 수 있다.

1. 데이터가 변경 됨.
   데이터가 변경 되었으므로 응답으로 받은 메시지를 사용해야 한다.
2. 데이터가 동일함.
   1. 검증헤더와 조건부 요청 1 (날짜 기반이므로 날짜는 다르지만 데이터가 동일한 경우에는 사용하지 못한다.)
      - 서버는 응답시 검증헤더 (Last-Modified : {날짜})를 응답 헤더에 넣어 응답한다.
      - 클라이언트는 응답 받은 헤더의 값을 캐시에 넣는다.
      - 클라이언트는 다음 요청시 if-modified-since : {Last-Modified 날짜}를 포함하여 서버에 요청한다.
      - 서버는 날짜를 비교하여 만약 수정이 일어나지 않았다면 302 Not Modified를 응답한다.
      - 클라이언트는 캐시에 저장되어 있는 데이터를 재활용한다.
   2. 검증헤더와 조건부 요청 2 (날짜 기반의 한계를 해결할 수 있다. 캐시 제어 로직을 서버에서 완전히 관리할 수 있다.)
      - 서버는 응답시 검증헤더 (ETag : {hash})를 응답 헤더에 넣어 응답한다.
      - 클라이언트는 응답 받은 헤더의 값을 캐시에 넣는다.
      - 클라이언트는 다음 요청시 if-None-Match : {ETag 값}를 포함하여 서버에 요청한다.
      - 서버는 비교하여 만약 수정이 일어나지 않았다면 302 Not Modified를 응답한다.

##### 캐시 제어 헤더

Cache-Control : max-age 유효시간 초단위

Cache-Control : no-cache 데이터는 캐시해도 되지만, 항상 서버에 검증하고 사용

Cache-Control : no-store 데이터에 민감한 정보가 있으므로 저장하면 안됨.

Cache-Control : public 응답이 public 캐시에 저장되어도 된다.

Cache-Control : privae 응답이 클라이언트에만 저장된다. (기본값)

Cache-Control : no-cache, no-store, must-revalidate 캐시를 사용하지 않는다.

Pragma : no-cache 캐시를 사용하지 않는다. (HTTP 1.0 하위 호환)





#### Reference

모든 개발자를 위한 HTTP 웹 기본 지식\_김영한\_인프런강의
